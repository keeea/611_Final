"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var useReceivePeerState = function (peerBrokerId, opts) {
    if (opts === void 0) { opts = { brokerId: '' }; }
    var _a = react_1.useState(undefined), state = _a[0], setState = _a[1];
    var _b = react_1.useState(false), isConnected = _b[0], setIsConnected = _b[1];
    var _c = react_1.useState(undefined), peer = _c[0], setPeer = _c[1];
    var _d = react_1.useState(opts.brokerId), brokerId = _d[0], setBrokerId = _d[1];
    var _e = react_1.useState(undefined), error = _e[0], setError = _e[1];
    react_1.useEffect(function () {
        if (!peerBrokerId) {
            return;
        }
        Promise.resolve().then(function () { return require('peerjs'); }).then(function (_a) {
            var Peer = _a.default;
            var localPeer = new Peer(opts.brokerId);
            setPeer(localPeer);
            localPeer.on('open', function () {
                if (brokerId !== localPeer.id) {
                    setBrokerId(localPeer.id);
                }
                var connection = localPeer.connect(peerBrokerId);
                connection.on('open', function () {
                    connection.on('data', function (receivedData) {
                        // We want isConnected and data to be set at the same time.
                        setState(receivedData);
                        setIsConnected(true);
                    });
                });
                connection.on('close', function () {
                    setIsConnected(false);
                });
                connection.on('error', function (err) { return setError(err); });
            });
            localPeer.on('error', function (err) { return setError(err); });
        });
        return function () {
            setIsConnected(false);
            peer && peer.destroy();
        };
    }, [peerBrokerId, opts.brokerId]);
    return [state, isConnected, error];
};
exports.default = useReceivePeerState;
